<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"config_config.js.html":{"id":"config_config.js.html","title":"Source: config/config.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: config/config.js /** * Config data pulled from the .env file * and some globally accessible internal variables * @module config/config * @version 2.0 */ module.exports = { /** * MongoDB is connected True/False * @type {boolean} */ dbConnected: false, /** * MQTT is connected True/False * @type {boolean} */ mqttConnected: false, /** * ISY Version returned from successful test of ISY credentials * @type {string} */ isyVersion: '', /** * Array of NodeServerModel objects kept in resident memory as reflection of their database models. * This allows for direct calling of NodeServerModel objects via nodeServers[profileNum]. The Array index * correlates to the NodeServer profileNum for ease of use. e.g. LiFX nodeserver with the profileNum of 8 * can be called via nodeServers[8].save() to save the NodeServer changes to the db for example. * @type {Array} */ nodeServers: new Array(11), /** * Settings Loaded from the ~/.polyglot/.env file using the dotenv NodeJS module. You SHOULD NEVER MODIFY THIS IN THE SOURCE. Just use the .env * isyHost = '192.168.1.10' * isyPort = '80' * isyUsername = 'admin' * isyPassword = 'password' * isyHttps = true/false (This isn't tested yet) * mqttHost = '192.168.1.12' (This CANNOT be 'localhost' or '127.0.0.1' as it is passed to the frontend for websocket connections. IT MUST BE THE HOST IP) * mqttPort = '1883' (Default is 1883) * mqttWSPort = '8083' (Default is 8083) * @type {Object} */ settings: { isyHost: process.env.ISY_HOST, isyPort: process.env.ISY_PORT, isyUsername: process.env.ISY_USERNAME, isyPassword: process.env.ISY_PASSWORD, isyHttps: process.env.ISY_HTTPS, mqttHost: process.env.MQTT_HOST, mqttPort: process.env.MQTT_PORT, mqttWSPort: process.env.MQTT_WSPORT } } × Search results Close "},"config_passport.js.html":{"id":"config_passport.js.html","title":"Source: config/passport.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: config/passport.js const JwtStrategy = require('passport-jwt').Strategy const ExtractJwt = require('passport-jwt').ExtractJwt const UserModel = require('../models/user') const config = require('../config/config') /** * The passport module to wrap all authenticated functions * that require the token to be accessed. * @module config/passport * @version 2.0 */ /** * Function to create the JWT Strategy for Passport. * @method * @param {module} passport - The Passport module is passed in to create a new JwtToken Strategy for authentication via header tokens. */ module.exports = function(passport){ let opts = {} opts.jwtFromRequest = ExtractJwt.fromAuthHeader() opts.secretOrKey = process.env.SECRET passport.use(new JwtStrategy(opts, (jwt_payload, done) =&gt; { UserModel.getUserById(jwt_payload._doc._id, (err, user) =&gt; { if (err) { return done(err, false) } if (user) { return done(null, user) } else { return done(null, false) } }) })) } × Search results Close "},"models_nodeserver.js.html":{"id":"models_nodeserver.js.html","title":"Source: models/nodeserver.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: models/nodeserver.js const mongoose = require('mongoose') //const randomstring = require('randomstring') const logger = require('../modules/logger') const config = require('../config/config') const mqtt = require('../modules/mqtt') const isy = require('../modules/isy') const async = require('async') /** * NodeServer Model and Parent Class. AddNS uses 'new NodeServerModel' to reference the NodeServerSchema parent class to create a new MongoDB document via Mongoose * @module models/nodeserver * @version 2.0 */ /** * MongoDB - Driver Child Schema * @class DriverSchema * @extends NodeSchema * @param {string} driver - Driver Name e.g. 'ST', 'RR', 'GV1', etc * @param {string} value - String representation of the value of the driver. * @param {number} uom - Integer of the UOM representing the value of the driver. */ const DriverSchema = mongoose.Schema({ driver: { type: String, required: true }, value: { type: String, default: null }, uom: { type: Number, default: null } }) /** * MongoDB - Nodes Child Schema * @class NodeSchema * @extends NodeServerModel * @param {string} address - Node address value e.g. 'lifxcontrol' * @param {boolean} added - Represents if the node is added and present in the ISY. * @param {boolean} enabled - Represents the enabled state of the node. * @param {string} name - Descriptive name of the node. * @param {string} node_def_id - Node Definition ID represented in the profile.zip for this node type. * @param {string} time_added - DateString in epoch of when the node was added to Polyglot * @param {string} primary - The node address of the nodes primary parent node. This could be itself in some cases. * @param {boolean} isprimary - Is this node a primary for other nodes. * @param {Object} drivers - Array of DriverSchema Objects */ const NodeSchema = mongoose.Schema({ address: { type: String, required: true }, added: { type: Boolean, default: false }, enabled: { type: Boolean, default: true }, name: { type: String, required: true }, node_def_id: { type: String, default: null }, time_added: { type: String, default: + new Date() }, primary: { type: String, default: null }, isprimary: { type: Boolean, default: false }, drivers: [DriverSchema] }) /** * MongoDB - NodeServer Parent Schema for creating a new NodeServer Database Object * @class NodeServerModel * @param {string} name - NodeServer name that is displayed in Polyglot. e.g. 'LiFX' or 'Nest' * @param {string} profileNum - ProfileNumber of the NodeServer. This must be a unique number between 1 - 10 that is not already defined in ISY. * @param {boolean} encryptPayload - Should we encrypt the payload using our .env secret? *[NOT IMPLEMENTED YET]* * @param {string} token - Encryption token taken from the .env file and saved to the DB *[NOT IMPLEMENTED YET]* * @param {string} time_added - DateString in epoch of when the NodeServer was added to Polyglot * @param {boolean} isConnected - Is Polyglot Connected to MQTT? * @param {string} logPrefix - Allows for custom logPrefixes to be defined per NodeServer if needed. * @param {Object} nodes - Array of NodeSchema Objects */ const NodeServerSchema = mongoose.Schema({ name: { type: String, required: true }, profileNum: { type: String, required: true, unique: true }, encryptPayload: { type: Boolean, default: false }, token: { type: String, default: null }, time_added: { type: String, default: + new Date() }, isConnected: { type: Boolean, default: false }, logPrefix: { type: String, default: null }, nodes: [NodeSchema] }) NodeServerSchema.statics = { /** * Sends an update to the frontend topic on detection of a change in NodeServer properties or sub properties like driver updates or state changes. * @method * @alias NodeServerModel.sendUpdate * @memberof module:models/nodeserver * @returns {object} response - MQTT Message sent to the frontends. e.g.: {&quot;nodeservers&quot;:[{&quot;name&quot;:&quot;LiFX&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;nodes&quot;:[{&quot;address&quot;:&quot;lifx_1234&quot;,&quot;name&quot;:&quot;LIFX_Lamp&quot;,&quot;_id&quot;:&quot;59338d1c2930bf7cc92842d1&quot;,&quot;drivers&quot;: [{&quot;driver&quot;:&quot;ST&quot;,&quot;_id&quot;:&quot;59338624cd92117adb9349ca&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;123.3&quot;},{&quot;driver&quot;:&quot;GV5&quot;,&quot;_id&quot;:&quot;59338624cd92117adb9349c9&quot;,&quot;uom&quot;:23,&quot;value&quot;:&quot;10&quot;}], &quot;isprimary&quot;:true,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496550684087&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true},{&quot;address&quot;:&quot;lifx_1235&quot;, &quot;name&quot;:&quot;Z_Strip&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d941&quot;,&quot;drivers&quot;: [{&quot;driver&quot;:&quot;ST&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d943&quot;,&quot;uom&quot;:56,&quot;value&quot;:&quot;593.3&quot;}, {&quot;driver&quot;:&quot;GV1&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d942&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:false,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496552508813&quot;, &quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true}],&quot;token&quot;:null,&quot;encryptPayload&quot;:false,&quot;time_added&quot;:&quot;1496545371618&quot;,&quot;isConnected&quot;:true}]} */ sendUpdate() { let ns = config.nodeServers.filter((ns) =&gt; { if (ns) return ns }) mqtt.publish('udi/polyglot/frontend/nodeservers', {node: 'polyglot', nodeservers: ns}, {retain: true}) }, /** * Frontend called method to add a new NodeServer * @method * @alias NodeServerModel.addns * @memberof module:models/nodeserver * @param {string} name - Name of NodeServer being added * @param {number} profileNum - Profile Number of NodeServer being added * @param {addnsCallback} callback - Callback with response JSON * @returns {object} response - AddNS: {&quot;addns&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;},&quot;seq&quot;:53407} Success: {&quot;seq&quot;:53407,&quot;response&quot;:{&quot;success&quot;:true,&quot;msg&quot;:&quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;,&quot;nodeserver&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;}}} Fail: {&quot;seq&quot;:53408,&quot;response&quot;:{&quot;success&quot;:false,&quot;msg&quot;:&quot;NodeServer with that Profile Number already exists.&quot;}} */ addns(name, profileNum, callback) { let newNodeServer = new NodeServerModel({ name: name, profileNum: profileNum, logPrefix: `${name}(${profileNum}):` }) const query = {profileNum: newNodeServer.profileNum} NodeServerModel.findOne(query, (err, node) =&gt; { if (err) { if (callback) return callback(err) } if (node) { if (callback) return callback(null, {success: false, msg: 'NodeServer with that Profile Number already exists.'}) } else { newNodeServer.installNodeServer((err, message) =&gt; { if (err) { logger.error(`${newNodeServer.logPrefix} Unable to register ${newNodeServer.name} with ISY. Reason: ${err}`) newNodeServer.remove() if (callback) return callback(null, {success: false, msg: err}) } else { newNodeServer.save((err, node) =&gt; { if (err) { if (callback) return callback(err) } if (!node) { if (callback) return callback(null, {success: false, msg: 'Failed to register NodeServer'}) } else { logger.info('Registered new NodeServer: ' + node.name + '(' + node.profileNum + ')') config.nodeServers[node.profileNum] = newNodeServer mqtt.addSubscription(node.profileNum) NodeServerModel.sendUpdate() if (callback) return callback(null, { success:true, msg: message, nodeserver: { name: node.name, profileNum: node.profileNum } }) } }) } }) } }) }, /** * Parse incoming Frontend messages * @method * @alias NodeServerModel.parseFrontend * @memberof module:models/nodeserver * @param {Object} message - Incoming JSON parsed object from the frontend. Only commands accepted are 'addns' and 'delns' currently */ parseFrontend(message) { if (message.hasOwnProperty('addns')) { if (message.addns.hasOwnProperty('name') &amp;&amp; message.addns.hasOwnProperty('profileNum')) { NodeServerModel.addns(message.addns.name, message.addns.profileNum, (err, result) =&gt; { if (err) return logger.debug(error) if (message.hasOwnProperty('seq')) { let response = { node: 'polyglot', seq: message.seq, response: result } mqtt.publish('udi/polyglot/frontend/nodeservers', response) NodeServerModel.sendUpdate() } }) } else { logger.error('MQTT: Received Add NodeServer command. name or profileNum was missing.') } } else if (message.hasOwnProperty('delns')) { if (message.delns.hasOwnProperty('profileNum')) { if (config.nodeServers[message.delns.profileNum]) { config.nodeServers[message.delns.profileNum].deleteNodeServer((err, result) =&gt; { if (message.hasOwnProperty('seq')) { let response = { node: 'polyglot', seq: message.seq, response: { success: err ? false: true, msg: err ? err : result } } mqtt.publish('udi/polyglot/frontend/nodeservers', response) NodeServerModel.sendUpdate() } }) } else { let response = { node: 'polyglot', seq: message.seq, response: { success: false, msg: `NodeServer with the profile number: ${message.delns.profileNum} does not exist.` } } mqtt.publish('udi/polyglot/frontend/nodeservers', response) } } else { logger.error('MQTT: Received Delete NodeServer command. profileNum was missing.') } } }, /** * Get all NodeServers from MongoDB * @method * @alias NodeServerModel.getAllNodeServers * @memberof module:models/nodeserver * @param {findArrayCallback} callback - Callback Passed into the Mongoose find method. * @returns {findArrayCallback} */ getAllNodeServers(callback) { return NodeServerModel.find({}, null, {sort: {'profileNum': 1}}, callback) }, /** * Get NodeServer from MongoDB by Name * @method * @alias NodeServerModel.getNodeByName * @memberof module:models/nodeserver * @param {string} name - Name of Node requested from MongoDB * @param {findCallback} callback - Callback Passed into the Mongoose find method. * @returns {findCallback} */ getNodeByName(name, callback) { let query = {name: name} return NodeServerModel.findOne(query, callback) }, /** * Get NodeServer from MongoDB by profileNum * @method * @alias NodeServerModel.getNodeByProfileNum * @memberof module:models/nodeserver * @param {number} number - profileNum of Node requested from MongoDB * @param {findCallback} callback - Callback Passed into the Mongoose find method. * @returns {findCallback} */ getNodeByProfileNum(num, callback) { const query = {profileNum: num} return NodeServerModel.findOne(query, callback) }, /** * Load all NodeServers from MongoDB on Polyglot Start-up * @method * @alias NodeServerModel.loadNodeServers * @memberof module:models/nodeserver * @param {errOnlyCallback} callback - Callback returned when complete */ loadNodeServers(callback) { NodeServerModel.getAllNodeServers((err, nodes) =&gt; { if(nodes) { nodes.forEach((nodeServer) =&gt; { if(config.nodeServers.filter((ns) =&gt; { return ns.profileNum === nodeServer.profileNum })) { logger.debug(`NodeServer ${nodeServer.name} [${nodeServer.profileNum}] added to running config.`) config.nodeServers[nodeServer.profileNum] = nodeServer nodeServer.getNodesFromISY() } }) logger.debug('MongoDB: NodeServers retrieved from database') } else { logger.debug('MongoDB: No NodeServers found in database') } if(callback) { return callback(err) } }) }, } NodeServerSchema.methods = { print () { return config.nodeServers[this.profileNum] }, /** * Instance Method for NodeServer to return a JSON object of itself. * @function toJSON * @alias NodeServerModel.toJSON * @memberof module:models/nodeserver~NodeServerModel * @instance * @returns {Object} nodeserver - Returns JSON parsed Object representation of the NodeServer */ toJSON() { let {name, profileNum, nodes, token, encryptPayload, time_added, isConnected} = this return JSON.parse(JSON.stringify({name, profileNum, nodes, token, encryptPayload, time_added, isConnected})) }, /** * Instance Method for NodeServer to check input from MQTT and execute function if successful. * Valid Commands: ['status', 'addnode','removenode', 'restcall', 'request', 'config', 'connected', 'command'] * @function checkCommand * @alias NodeServerModel.checkCommand * @memberof module:models/nodeserver~NodeServerModel * @instance */ checkCommand(data){ //if (this.isConnected) { let validCommands = ['status', 'addnode','removenode', 'restcall', 'request', 'config', 'connected', 'command'] for (var prop in data) { if (prop === 'node') { continue } if (validCommands.indexOf(prop) &lt; 0) { logger.error(`${this.logPrefix} ${prop} not in valid commands list`) continue } logger.info(`${this.logPrefix} Processing command: ${prop}`) if (data.hasOwnProperty(prop)) { (this[prop] || this['notfound']).call(this, data[prop], prop) } else { logger.debug(`${this.logPrefix} Property not found in input: ${data}`) } } //} else { // logger.error(`${this.logPrefix} is not connected. Make sure you send connected: true as the first message.`) //} }, /** * Instance Method for NodeServer to handle 'status' * @function status * @alias NodeServerModel.status * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming command message e.g. {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;driver&quot;: &quot;GV6&quot;, &quot;value&quot;: 50.2, &quot;uom&quot;: 20} * @param {string} command - The command received: 'status' * @returns {object} response - ONLY if an error occurs will a MQTT response message will be sent back to the NodeServer: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:404,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;9.735427ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;status&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1234 or GV18 does not exist&quot;,&quot;address&quot;:&quot;lifx_1234&quot;}}} */ status(data, command) { // Profile#, incoming json, command &quot;status&quot;, full response text (t/f) isy.handleRequest(this.profileNum, data, command, false, (result) =&gt; { if (result.statusCode === 404) { let reason = `${data.address} or ${data.driver} does not exist` this.sendResult(command, result, false, reason, {address: data.address}) logger.error(`${this.logPrefix} ${reason}`) } else if (result.statusCode === 200){ let success = false for (var node in this.nodes) { if (this.nodes[node].address === data.address) { for (var driver in this.nodes[node].drivers) { if (this.nodes[node].drivers[driver].driver === data.driver) { this.nodes[node].drivers[driver].uom = data.uom this.nodes[node].drivers[driver].value = data.value success = true this.save(() =&gt; { let reason = `${data.address} ${data.driver} set sucessfully to ${data.value}` //this.sendResult(command, result, true, reason, {address: data.address}) logger.info(`${this.logPrefix} ${reason}`) NodeServerModel.sendUpdate() }) } } } } if (!success) { let reason = `${data.address} driver ${data.driver} does not exist in the Polyglot database.` this.sendResult(command, result, false, reason, {address: data.address}) logger.error(`${this.logPrefix} ${reason}`) } } }) }, /** * Instance Method for NodeServer to handle 'command' * @function command * @alias NodeServerModel.command * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming message e.g. {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;command&quot;: &quot;DON&quot;, &quot;value&quot;: 50.2, &quot;uom&quot;: 20} * @param {string} command - The command received: 'command' * @returns {object} response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;true&quot;,&quot;status&quot;:&quot;200&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;0&quot;}}},&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;19.073624ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;command&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;lifx_1234 DON sent sucessfully with 50.2&quot;,&quot;address&quot;:&quot;lifx_1234&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;400&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;2101&quot;}}},&quot;statusCode&quot;:400,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;10.852264ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;command&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_123 or asdf does not exist or is incorrect&quot;,&quot;address&quot;:&quot;lifx_123&quot;}}} */ command(data, command) { isy.handleRequest(this.profileNum, data, command, true, (result) =&gt; { if (result.statusCode === 404 || result.statusCode === 400) { let reason = `${data.address} or ${data.command} does not exist or is incorrect` this.sendResult(command, result, false, reason, {address: data.address}) logger.error(`${this.logPrefix} ${reason}`) } else if (result.statusCode === 200){ let reason = `${data.address} ${data.command} sent sucessfully with ${data.value}` this.sendResult(command, result, true, reason, {address: data.address}) logger.info(`${this.logPrefix} ${reason}`) NodeServerModel.sendUpdate() } }) }, /** * Instance Method for NodeServer to handle 'restcall' * @function restcall * @alias NodeServerModel.restcall * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming message e.g. {&quot;api&quot;:&quot;nodes/n001_d073d51327cc&quot;,&quot;seq&quot;:10068,&quot;timeout&quot;:null} * @param {string} command - The command received: 'restcall' * @returns {object} response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;nodeInfo&quot;:{&quot;node&quot;:{&quot;flag&quot;:&quot;0&quot;,&quot;nodeDefId&quot;:&quot;lifxcolor&quot;,&quot;address&quot;:&quot;n001_d073d51327cc&quot;,&quot;name&quot;:&quot;LIFX Lamp&quot;,&quot;family&quot;:{&quot;instance&quot;:&quot;1&quot;,&quot;$t&quot;:&quot;10&quot;},&quot;parent&quot;:{&quot;type&quot;:&quot;1&quot;,&quot;$t&quot;:&quot;n001_lifxcontrol&quot;},&quot;type&quot;:&quot;1.1.0.0&quot;,&quot;enabled&quot;:&quot;true&quot;,&quot;deviceClass&quot;:&quot;0&quot;,&quot;wattage&quot;:&quot;0&quot;,&quot;dcPeriod&quot;:&quot;0&quot;,&quot;startDelay&quot;:&quot;0&quot;,&quot;endDelay&quot;:&quot;0&quot;,&quot;pnode&quot;:&quot;n001_lifxcontrol&quot;,&quot;ELK_ID&quot;:&quot;A07&quot;},&quot;properties&quot;:{}}},&quot;statusCode&quot;:200,&quot;seq&quot;:10068,&quot;elapsed&quot;:&quot;29.861932ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;restcall&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;nodes/n001_d073d51327cc executed sucessfully&quot;,&quot;api&quot;:&quot;nodes/n001_d073d51327cc&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;404&quot;}},&quot;statusCode&quot;:404,&quot;seq&quot;:10068,&quot;elapsed&quot;:&quot;15.433125ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;restcall&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;ISY Returned 404 for nodes/n001_d073d51327c&quot;,&quot;api&quot;:&quot;nodes/n001_d073d51327c&quot;}}} */ restcall(data, command) { isy.handleRequest(this.profileNum, data, command, true, (result) =&gt; { if (result.statusCode === 404) { let reason = `ISY Returned 404 for ${data.api}` this.sendResult(command, result, false, reason, {api: data.api}) logger.error(`${this.logPrefix} ${reason}`) } else if (result.statusCode === 200){ let reason = `${data.api} executed sucessfully` this.sendResult(command, result, true, reason, {api: data.api}) logger.info(`${this.logPrefix} ${reason}`) } }) }, /** * Instance Method for NodeServer to handle 'addnode' * @function addnode * @alias NodeServerModel.addnode * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming message e.g. {&quot;nodes&quot;: [{&quot;address&quot;: &quot;lifx_1236&quot;,&quot;name&quot;: &quot;LIFX_Lamp2&quot;,&quot;node_def_id&quot;: &quot;lifxcolor&quot;,&quot;primary&quot;: &quot;lifx_1234&quot;,&quot;drivers&quot;: [{&quot;driver&quot;: &quot;ST&quot;,&quot;value&quot;: &quot;123.3&quot;,&quot;uom&quot;: 20},{&quot;driver&quot;: &quot;GV5&quot;,&quot;value&quot;: &quot;10&quot;,&quot;uom&quot;: 23}]}], &quot;seq&quot;: 1000} * @param {string} command - The command received: 'addnode' * @returns {object} response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:1000,&quot;elapsed&quot;:&quot;100.425214ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;node lifx_1236 added successfully.&quot;,&quot;address&quot;:&quot;lifx_1236&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;25.251796ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1235 already exists on ISY&quot;,&quot;address&quot;:&quot;lifx_1235&quot;}}} */ addnode(data, command) { if (!Array.isArray(data.nodes)) return logger.error(`${this.logPrefix} - nodes must be an array.`) let primaryNodes = [] for (i in data.nodes) { if (data.nodes[i].address === data.nodes[i].primary) { primaryNodes.push(data.nodes.splice(i, 1)[0]) } } async.each(primaryNodes, (node, callback) =&gt; { this.doNodeAdd(node, command, data, (err) =&gt; { if (err) { callback(err) } else { callback() } }) }, (err) =&gt; { if (err) {logger.error(`${this.logPrefix} Error adding primary node: ${err}`)} async.each(data.nodes, (node, callback) =&gt; { this.doNodeAdd(node, command, data, (err) =&gt; { if (err) { callback(err) } else { callback() } }) }, (err) =&gt; { if (err) { logger.error(`${this.logPrefix}: ${err}`) } else { logger.info(`${this.logPrefix} completed adding node(s).`) NodeServerModel.sendUpdate() this.config() } }) }) }, doNodeAdd(node, command, data, finishcb){ if (!Array.isArray(node.drivers)) { let reason = `${node.address} drivers must be an array.` this.sendResult(command, results, false, reason, {address: node.address}) return finishcb(reason) } async.waterfall([ function (callback){ NodeServerModel.count({profileNum: this.profileNum, 'nodes.address': node.address}, (err, result) =&gt; { if (err) { return callback(err) } else { return callback(null, result) } }) }.bind(this), function (result, callback) { isy.handleRequest(this.profileNum, {api: 'nodes/' + isy.addNodePrefix(this.profileNum, node.address), seq: data.seq ? data.seq : false}, 'restcall', false, (results) =&gt; { if (results.statusCode !== 404) { let reason = `${node.address} already exists on ISY` this.sendResult(command, results, false, reason, {address: node.address}) return callback(reason) } if (result) { logger.info(`${this.logPrefix} ${node.address} already exists in ${this.name} but does not exist on the ISY. Removing local copy and overwriting.`) for (i in this.nodes) { if (this.nodes[i].address === node.address) { this.nodes[i].remove(this.save((err) =&gt; { if (err) return callback(err) return callback() })) } } } else { return callback() } }) }.bind(this), function(callback) { let newNode = { address: node.address, name: node.name, node_def_id: node.node_def_id, primary: node.primary, drivers: node.drivers, seq: data.seq ? data.seq : false } let primaryFound = false if (node.address === node.primary) { newNode.isprimary = true primaryFound = true } for (i in this.nodes) { if (this.nodes[i].address === node.primary) { if (!(this.nodes[i].primary === this.nodes[i].address)) { let reason = `${node.primary} is not a primary. Only single layer nesting allowed.` this.sendResult(command, {profileNum: this.profileNum}, false, reason, {address: node.address}) return callback(reason) } else { this.nodes[i].isprimary = true primaryFound = true } } } if (!primaryFound) { let reason = `Primary node ${node.primary} was not found in nodes.` this.sendResult(command, {}, false, reason, {address: node.address}) return callback(reason) } isy.handleRequest(this.profileNum, newNode, command, false, (result) =&gt; { if (result.statusCode == 400) { let reason = `${newNode.address} already exists.` this.sendResult(command, result, false, reason, {address: node.address}) return callback(reason) } else if (result.statusCode == 200) { newNode.added = true this.nodes.push(newNode) this.save((err) =&gt; { if (err) return callback(err) let reason = `node ${newNode.address} added successfully.` this.sendResult(command, result, true, reason, {address: newNode.address}) logger.info(`${this.logPrefix} ${reason}`) return callback() }) } else { return callback() } }) }.bind(this) ], (err) =&gt; { if (err) { return finishcb(err) } else { return finishcb()} }) }, /** * Instance Method for NodeServer to handle 'removenode' * @function removenode * @alias NodeServerModel.removenode * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming message e.g. {&quot;node&quot;: &quot;1&quot;, &quot;removenode&quot;: {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;seq&quot;: 1004}} * @param {string} command - The command received: 'removenode' * @returns {object} response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;true&quot;,&quot;status&quot;:&quot;200&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;0&quot;}}},&quot;statusCode&quot;:200,&quot;seq&quot;:1004,&quot;elapsed&quot;:&quot;99.309321ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;removenode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;lifx_1235 removed successfully&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;403&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;5106&quot;}}},&quot;statusCode&quot;:403,&quot;seq&quot;:1004,&quot;elapsed&quot;:&quot;17.747168ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;removenode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;Could not remove lifx_1234. It is the primary for another node.&quot;}}} */ removenode(data, command, callback = null) { isy.handleRequest(this.profileNum, data, command, true, (result) =&gt; { let success = false let reason = null let message = null if (result.statusCode === 200) { for (i in this.nodes) { if (this.nodes[i].address === data.address) { this.nodes[i].remove((err) =&gt; { if (err) { if (callback) return callback(err) else return logger.error(`${this.logPrefix} dberror on removenode`) } else { success = true message = `${data.address} removed successfully` this.save(() =&gt; { logger.info(`${this.logPrefix} node ${message}`) NodeServerModel.sendUpdate() }) this.sendResult(command, result, success, message) } }) } } } else if (result.statusCode === 403) { if (result.isyresponse.RestResponse.reason.code === &quot;5106&quot;) { reason = `Could not remove ${data.address}. It is the primary for another node.` logger.error(`${this.logPrefix} ${reason}`) this.sendResult(command, result, success, reason) } else if (result.isyresponse.RestResponse.reason.code === &quot;5003&quot;) { reason = `Could not remove ${data.address}. It doesn't exist in ISY. Will remove from DB if it exists.` logger.info(`${this.logPrefix} ${reason}`) for (i in this.nodes) { if (this.nodes[i].address === data.address) { this.nodes[i].remove((err) =&gt; { if (err) { if (callback) return callback(err) else return logger.error(`${this.logPrefix} dberror on removenode`) } else { success = true message = `${data.address} removed successfully` this.save(() =&gt; { logger.info(`${this.logPrefix} node ${message}`) NodeServerModel.sendUpdate() }) this.sendResult(command, result, success, message) } }) } } } else { reason = `Could not remove ${data.address}. ISY sent 403.` logger.error(`${this.logPrefix} ${reason}`) this.sendResult(command, result, success, reason) } } if (callback) return callback() }) }, /** * Instance Method to Query for Nodes for this NodeServer from ISY * This happens at Polyglot Startup to Sync the ISY and Polyglot Database * @function getNodesFromISY * @alias NodeServerModel.getNodesFromISY * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {errOnlyCallback} callback - Callback when complete with only parameter being an error if there was one. */ getNodesFromISY(callback) { isy.handleRequest(this.profileNum, {api: 'profiles/ns/' + this.profileNum + '/connection'}, 'restcall', true, (results) =&gt; { if (!results) { if (callback) { return callback('No ISY Response') } else return } try { if (results.isyresponse.connections.connection &amp;&amp; results.statusCode === 200) { if (this.profileNum === results.isyresponse.connections.connection.profile) { logger.info(`${this.logPrefix} - NodeServer found on ISY with the name ${results.isyresponse.connections.connection.name}. Checking for Nodes...`) async.each(this.nodes, (node, asyncCb) =&gt; { if (!node.isprimary) { return asyncCb() } isy.handleRequest(this.profileNum, {api: 'nodes/' + isy.addNodePrefix(this.profileNum, node.address)}, 'restcall', true, (results) =&gt; { if (results.statusCode === 404) { logger.info(`${this.logPrefix} ${node.address} doesn't exist in ISY. Adding...`) this.doNodeAdd(node, 'addnode', (err) =&gt; { if (err) { return asyncCb(err) } else { return asyncCb() } }) } else { logger.info(`${this.logPrefix} ${node.address} already exists in ISY. Skipping...`) return asyncCb() } }) }, (err) =&gt; { if (err) { logger.error(`${this.logPrefix} Error adding node: ${err}`) if (callback) callback(err) } else { async.each(this.nodes, (node, asyncCb) =&gt; { if (node.isprimary) { return asyncCb() } isy.handleRequest(this.profileNum, {api: 'nodes/' + isy.addNodePrefix(this.profileNum, node.address)}, 'restcall', true, (results) =&gt; { if (results.statusCode === 404) { logger.info(`${this.logPrefix} ${node.address} doesn't exist in ISY. Adding...`) this.doNodeAdd(node, 'addnode', (err) =&gt; { if (err) { return asyncCb(err) } else { return asyncCb() } }) } else { logger.info(`${this.logPrefix} ${node.address} already exists in ISY. Skipping...`) return asyncCb() } }) }, (err) =&gt; { if (err) { logger.error(`${this.logPrefix} Error adding node: ${err}`) if (callback) callback(err) } else { logger.info(`${this.logPrefix} Completed ReSync with ISY.`) if (callback) callback() } }) } }) } } } catch (err) { if (callback) return callback(err) else return err } }) }, /** * Instance Method to install this NodeServer to ISY automatically. This kicks off immediately after NodeServer is added to Polyglot via the frontend. * @function installNodeServer * @alias NodeServerModel.installNodeServer * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {responseCallback} callback - (err, response) Callback when complete with error if present, or response if no error. */ installNodeServer(callback) { logger.info(`${this.logPrefix} Attempting to install ${this.name} NodeServer into ISY.`) isy.handleRequest(this.profileNum, {api: 'profiles/ns/' + this.profileNum + '/connection'}, 'restcall', true, (results) =&gt; { if (!results.isyresponse.connections.connection &amp;&amp; results.statusCode === 200){ let args = { ip: process.env.HOST_IP, baseurl: '/ns/' + this.profileNum, name: this.name, nsuser: 'polyglot', nspwd: 'gTmZznSGe9Es6FTJ', isyusernum: 0, port: process.env.HOST_PORT, timeout: 0, ssl: process.env.USE_HTTPS, enabled: true } isy.handleRequest(this.profileNum, {api: 'profiles/ns/' + this.profileNum + '/connection/set/network', args: args}, 'restcall', true, (results) =&gt; { if (results.statusCode !== 200) { let message = `Failed to install NodeServer. ISY responded with other than 200.` callback(message) } else { let message = `Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip` logger.info(`${this.logPrefix} ${message}`) callback(null, message) } }) } else if (results.isyresponse.connections.connection &amp;&amp; results.statusCode === 200){ let message = 'That Profile already exists on the ISY.' logger.error(`${this.logPrefix} ${message}`) callback(message) } else { let message = 'ISY sent a bad status code or did not respond. Check your settings.' logger.error(`${this.logPrefix} ${message}`) callback(message) } }) }, /** * Instance Method to delete this NodeServer from ISY automatically. This kicks off immediately after NodeServer is deleted via the frontend. * @function deleteNodeServer * @alias NodeServerModel.deleteNodeServer * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {responseCallback} callback - (err, response) Callback when complete with error if present, or response if no error. */ deleteNodeServer(callback) { logger.info(`${this.logPrefix} attempting to delete NodeServer ${this.name}`) logger.info(`${this.logPrefix} deleting ${this.name}'s nodes from ISY.`) async.each(this.nodes, (node, callback) =&gt; { if (node){ if (node.isprimary) return callback() this.removenode(node, 'removenode', (err, result) =&gt; { if (err) return callback(err) else { callback() } }) } else { callback() } }, (err) =&gt; { if (err) return callback(err) else { async.each(this.nodes, (node, callback) =&gt; { if (node){ this.removenode(node, 'removenode', (err, result) =&gt; { if (err) return callback(err) else { callback() } }) } else { callback() } }, (err) =&gt; { if (err) return callback(err) isy.handleRequest(this.profileNum, {api: 'profiles/ns/' + this.profileNum + '/connection/remove'}, 'restcall', true, (result) =&gt; { if (result.statusCode === 200) { let message = `${this.logPrefix} ` this.remove((err) =&gt; { if (err) return callback(err) message += 'Succesfully removed NodeServer. You must reboot the ISY.' delete config.nodeServers[this.profileNum] logger.info(`${message}`) callback(null, message) }) } else { let message = `${this.logPrefix} ISY returned something other than 200, this usually means the NodeServer is out of range. Deleting from DB... ` this.remove((err) =&gt; { if (err) return callback(err) message += 'Success' logger.info(`${message}`) callback(null, message) }) } }) }) } }) }, /** * Instance Method to Send a result message to the NodeServer via MQTT * @function sendResult * @alias NodeServerModel.sendResult * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {string} command - Command NodeServer is sending a result for. * @param {Object} result - The result object data. * @param {boolean} success - True/false * @param {string} reason - Sucess reason * @param {Object} extra - Extra Parameters to send to the NodeServer if needed. */ sendResult(command, result, success, reason, extra = null) { result[command] = { success: success, reason: reason } if (extra) { result[command] = Object.assign(result[command], extra) } mqtt.makeResponse(this.profileNum, 'result', result) }, /** * Instance Method to handle 'request' from NodeServer * @function request * @alias NodeServerModel.request * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {Object} data - {&quot;node&quot;: &quot;8&quot;, &quot;request&quot;: {&quot;requestId&quot;: &quot;3949&quot;, &quot;success&quot;: true}} * @param {string} command - This command 'request'. * @returns {Object} result - Responds only on failure. Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:404,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;8.202375ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;request&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;ISY Returned 404 for request ID: 22&quot;,&quot;id&quot;:&quot;22&quot;}}} */ request(data, command) { isy.handleRequest(this.profileNum, data, command, false, (result) =&gt; { if (result.statusCode === 404 || result.statusCode === 400) { let reason = `ISY Returned 404 for request ID: ${data.requestId}` this.sendResult(command, result, false, reason, {id: data.requestId}) logger.error(`${this.logPrefix} ${reason}`) } else if (result.statusCode === 200){ let reason = `${data.requestId} reported sucessfully as ${data.success}` this.sendResult(command, result, true, reason, {id: data.requestId}) logger.info(`${this.logPrefix} ${reason}`) } }) }, /** * Instance Method to handle 'config' from NodeServer * @function config * @alias NodeServerModel.config * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {Object} data - {&quot;node&quot;: &quot;1&quot;, &quot;config&quot;: null, &quot;seq&quot;: 1000} * @param {string} command - This command 'config'. * @returns {Object} response - Returns existing NodeServer configuration: {&quot;config&quot;:{&quot;name&quot;:&quot;LiFX&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;nodes&quot;:[{&quot;address&quot;:&quot;lifx_1234&quot;,&quot;name&quot;:&quot;LIFX_Lamp2&quot;,&quot;drivers&quot;:[{&quot;driver&quot;:&quot;ST&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;123.3&quot;},{&quot;driver&quot;:&quot;GV5&quot;,&quot;uom&quot;:23,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:true,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496550684087&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true},{&quot;address&quot;:&quot;lifx_1235&quot;,&quot;name&quot;:&quot;TouchMe&quot;,&quot;drivers&quot;:[{&quot;driver&quot;:&quot;ST&quot;,&quot;uom&quot;:56,&quot;value&quot;:&quot;593.3&quot;},{&quot;driver&quot;:&quot;GV1&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:false,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496552508813&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true}],&quot;token&quot;:null,&quot;encryptPayload&quot;:false,&quot;time_added&quot;:&quot;1496545371618&quot;,&quot;isConnected&quot;:false}} */ config(data = null, command = null) { // Hack to deepcopy this.nodes var parseConfig = this.toJSON() parseConfig._id = undefined parseConfig.nodes.forEach((node) =&gt; { node._id = undefined node.drivers.forEach((driver) =&gt; { driver._id = undefined }) }) mqtt.makeResponse(this.profileNum, 'config', parseConfig) }, /** * Instance Method to handle 'connected' from NodeServer * @function connected * @alias NodeServerModel.connected * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {Object} data - {&quot;node&quot;: &quot;1&quot;, &quot;connected&quot;: true} or {&quot;node&quot;: &quot;1&quot;, &quot;connected&quot;: false} * @param {string} command - This command 'connected'. */ connected(data, command) { this.isConnected = data this.save(() =&gt; { logger.info(`${this.logPrefix} NodeServer ${(data ? 'Connected.' : 'Disconnected.')}`) this.config(data, command) NodeServerModel.sendUpdate() }) }, notfound(data, command) { logger.info(`${this.logPrefix} command not found: ${command}`) } } NodeServerModel = mongoose.model('NodeServer', NodeServerSchema) module.exports = NodeServerModel /** @callback addnsCallback @param {string} error - An Error if returned @param {Object} response - {&quot;seq&quot;:53407,&quot;response&quot;:{&quot;success&quot;:true,&quot;msg&quot;:&quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;,&quot;nodeserver&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;}}} */ /** @callback findArrayCallback @param {string} error - An Error if encountered @param {Object} documents - Array of documents returned by Mongoose Find */ /** @callback findCallback @param {string} error - An Error if encountered @param {Object} document - Document returned by Mongoose FindOne */ /** @callback errOnlyCallback @param {string} error - An Error if encountered */ /** @callback responseCallback @param {string} error - An Error if encountered @param {Object} response - Object response returned to callback if no error occurred. */ × Search results Close "},"models_user.js.html":{"id":"models_user.js.html","title":"Source: models/user.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: models/user.js const mongoose = require('mongoose') const bcrypt = require('bcryptjs') //const config = require('../config/config') var logger = require('../modules/logger') /** * User Model and Class. * @module models/user * @version 2.0 */ /** * MongoDB - UserSchema for creating a new User Database Object * @class UserModel * @param {string} username - Username of new User * @param {string} password - Password of new User */ const UserSchema = mongoose.Schema({ username: { type: String, required: true }, password: { type: String, required: true } }) UserSchema.statics = { /** * MongoDB gets user from database by ID. * @method * @alias UserModel.sendUpdate * @memberof module:models/user * @param {string} id - ID to search for. * @param {findCallback} callback - Callback Passed into the Mongoose find method. */ getUserById (id, callback){ UserModel.findById(id, callback) }, /** * MongoDB gets user from database by Username. * @method * @alias UserModel.getUserByUsername * @memberof module:models/user * @param {string} username - Username to search for. * @param {findCallback} callback - Callback Passed into the Mongoose find method. */ getUserByUsername (username, callback){ const query = {username: username} UserModel.findOne(query, callback) }, /** * Adduser salts and hashes the password using bcrypt before saving it to the database. * &lt;TODO&gt; This has become problematic on older machines such as the Raspberry Pi 1. * It is extremely slow to do the comparison. Gotta find a better way. Maybe less salts. * @method * @alias UserModel.addUser * @memberof module:models/user * @param {Object} newUser - new instance of UserModel * @param {saveCallback} callback - Callback Passed into the Mongoose find method. */ addUser (newUser, callback){ bcrypt.genSalt(10, (err, salt) =&gt; { bcrypt.hash(newUser.password, salt, (err, hash) =&gt; { if(err) throw err newUser.password = hash newUser.save(callback) logger.info(`User: Created new user ${newUser.username}`) }) }) }, /** * Compare salts and hashes with the password using bcrypt. * &lt;TODO&gt; This has become problematic on older machines such as the Raspberry Pi 1. * It is extremely slow to do the comparison. Gotta find a better way. Maybe less salts. * @method * @alias UserModel.addUser * @memberof module:models/user * @param {string} password - Password attempting to authenticate with. * @param {compareCallback} callback - Callback Passed into the Mongoose find method. */ comparePassword (candidatePassword, hash, callback) { bcrypt.compare(candidatePassword, hash, (err, isMatch) =&gt; { if(err) throw err callback(null, isMatch) }) } } UserModel = mongoose.model('User', UserSchema) module.exports = UserModel /** @callback findCallback @param {string} error - An Error if encountered @param {Object} document - Document returned by Mongoose FindOne */ /** @callback saveCallback @param {string} error - An Error if encountered @param {Object} document - Document returned if sucessfully saved by Mongoose save method */ /** @callback compareCallback @param {string} error - An Error if encountered @param {boolean} isMatch - True/False is password hashed successfully with bcrypt. */ × Search results Close "},"modules_db.js.html":{"id":"modules_db.js.html","title":"Source: modules/db.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/db.js const mongoose = require('mongoose') const config = require('../config/config') const SettingsModel = require('../models/settings') const NodeServerModel = require('../models/nodeserver') const UserModel = require('../models/user') const isy = require('../modules/isy') const logger = require('./logger') const mqtt = require('./mqtt') mongoose.Promise = global.Promise /** * Database Module * @module modules/db * @version 2.0 */ module.exports = { /** MongoDB Connection var */ Server: null, /** * MongoDB Start Service and Connect via .env MONGO_URI provided. * @method * @param {startCallback} callback - Callback when connected and all NodeServers were retrieved. */ startService(callback) { if (process.env.MONGO_URI === undefined) { logger.error('Could not find DB URI...') if (callback) return callback('shutdown') } if (!this.Server) { // Connect to database opts = { server: { reconnectTries: Number.MAX_VALUE, reconnectInterval: 5000 } } this.Server = mongoose.connect(process.env.MONGO_URI, opts) // On Connection mongoose.connection.on('connected', () =&gt; { logger.info('MongoDB: Connected') config.dbConnected = true isy.getVersion() /* SettingsModel.getSettings((err, data) =&gt; { logger.debug('MongoDB: Config received from database') config.settings = data isy.getVersion(() =&gt; { config.settings.save() }) }) */ NodeServerModel.loadNodeServers(()=&gt; { if (callback) { return callback()} }) }) mongoose.connection.on('disconnected', () =&gt; { config.dbConnected = false logger.error('MongoDB: Disconnected from database. Retrying every 5 seconds.') }) // On Error mongoose.connection.on('error', (err) =&gt; { logger.error('MongoDB: ' + err) config.dbConnected = false this.Server.disconnect() }) } }, /** * MongoDB Stop Service run on program shutdown. * @method * @param {stopCallback} callback - Callback when shutdown or error. */ stopService(callback) { if (this.Server) { this.Server.disconnect((err) =&gt; { this.Server = null logger.info('MongoDB: Disconnected') if(callback) { callback() } }) } else { if(callback) { callback() } } } } /** @callback startCallback @param {string} error - An Error if encountered @param {Object} documents - Documents returned if sucessfully connected and retrieved existing NodeServer documents. */ /** @callback stopCallback @param {string} error - An Error if encountered */ × Search results Close "},"modules_encryption.js.html":{"id":"modules_encryption.js.html","title":"Source: modules/encryption.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/encryption.js // Nodejs encryption with CTR const crypto = require('crypto'); const algorithm = 'aes-256-ctr'; const encoding = ',2YE6=#r(z5?Y4=a'; /** * The encryption module to encrypt communications between NodeServers and Polyglot * this is tested, however it is not enabled as of release 2.0 * @module modules/encryption * @version 2.0 */ /** * encryptText * @param {string} text - Text to encrypt * @returns {string} Encrypted Text */ module.exports.encryptText = function(text) { var cipher = crypto.createCipher(algorithm, encoding) var crypted = cipher.update(text,'utf8','hex') crypted += cipher.final('hex'); return crypted; } /** * decryptText * @param {string} text - Text to decrypt * @returns {string} Decrypted Text */ module.exports.decryptText = function(text) { var decipher = crypto.createDecipher(algorithm, encoding) var dec = decipher.update(text, 'hex','utf8') dec += decipher.final('utf8'); return dec; } × Search results Close "},"modules_helpers.js.html":{"id":"modules_helpers.js.html","title":"Source: modules/helpers.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/helpers.js const logger = require('../modules/logger') const config = require('../config/config') const SettingsModel = require('../models/settings') const NodeServerModel = require('../models/nodeserver') const db = require('../modules/db') const mqtt = require('../modules/mqtt') const web = require('../modules/web') const async = require('async') /** * Generic Helpers Module that has a couple of various methods that didn't fit elsewhere. * @module modules/helpers * @version 2.0 */ module.exports = { /* checkServices() { if (!mqtt.Client) { mqtt.startService(() =&gt; { this.resyncNodesToISY() }) } else { mqtt.stopService() } }, */ /** * resyncNodesToISY wraps a couple of database/ISY checks to make sure the ISY and Local MongoDB are in sync. * @param {function} callback - Simple callback function that returns on error or when function is complete. */ resyncNodesToISY(callback=null) { logger.info(`ReSyncing NodeServers with ISY...`) async.each(config.nodeServers, (nodeServer, callback) =&gt; { if (!nodeServer) { return callback() } nodeServer.getNodesFromISY(() =&gt; { if (callback) return callback() }) }, (err) =&gt; { if (err) { logger.error(`ReSync NodeServers ERROR: ${err}`) if (callback) return callback(err) } else { SettingsModel.sendUpdate() NodeServerModel.sendUpdate() if (callback) return callback() } }) }, /** * restartServices is an external function to stop then restart the MQTT service and re-initiate a NodeServer Resync */ restartServices() { mqtt.stopService(() =&gt; { setTimeout(() =&gt; { mqtt.startService(() =&gt; { this.resyncNodesToISY() }) },1000) }) }, /** * shutdown is the program stop function to terminate the application gracefully. */ shutdown() { async.series([ this.saveNodeServers(), //web.stopService(), mqtt.stopService(), db.stopService(), process.exit(0) ]) }, /** * saveNodeServers will cycle through all the NodeServers and save the current state to MongoDB. This occurrs automatically before shutdown. */ saveNodeServers(callback) { config.nodeServers.forEach((nodeServer) =&gt; { logger.debug(`Saving NodeServer ${nodeServer.name} to database.`) nodeServer.save() if (callback) { return callback() } }) } } × Search results Close "},"modules_isy.js.html":{"id":"modules_isy.js.html","title":"Source: modules/isy.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/isy.js const logger = require('./logger') const config = require('../config/config') require('http').globalAgent.maxSockets = Infinity const request = require('request') const encrypt = require('./encryption') const xmlparser = require('xml2json-light') const querystring = require('querystring') const mqtt = require('./mqtt') /** * ISY API Module for REST calls to the ISY Interfaces * @module modules/isy * @version 2.0 */ module.exports = { /** * Automactially adds the ISY Node Prefix onto the address before querying the API. * @method * @param {number} profileNum - The NodeServer profileNum. * @param {string} nod - The NodeServer address id */ addNodePrefix(profileNum, nid) { return `n${('00' + profileNum).slice(-3)}_${nid}`.slice(0, 20) }, /** * Creates the API URL to query ISY * /rest/{api}/?{path_args} * @method * @param {string} api - The ISY API path to query * @param {object} path_args - Dictionary of path arguments appended to the URL. */ makeApiUrl(api, path_args = null) { url = `${process.env.ISY_HTTPS === 'true' ? 'https://' : 'http://'}${process.env.ISY_HOST}:${process.env.ISY_PORT}/rest/${api}/` if (path_args) { url += '?' + querystring.stringify(path_args) } //url = encodeURI(url) return url }, /** * Creates the Node URL to query ISY * /rest/ns/{profileNum}/{path}/?{path_args} * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} path - The ISY path to query * @param {object} path_args - Dictionary of path arguments appended to the URL. */ makeNodeUrl(profileNum, path, path_args) { url = `${process.env.ISY_HTTPS === 'true' ? 'https://' : 'http://'}${process.env.ISY_HOST}:${process.env.ISY_PORT}/rest/ns/${profileNum}/${path.join('/')}` if (path_args) { url += '?' + querystring.stringify(path_args).trim() } //url = encodeURI(url) return url }, /** * Performs the actual query to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} url - The URL created by makeNodeUrl or makeApiUrl * @param {number} seq - Sequence number to verify response on specific call * @param {boolean} getText - Get full response text from ISY and package it in the response. True/False * @param {function} callback - Simple (err, response) callback with the result success or fail. */ getIsy(profileNum, url, seq, getText, callback){ var options = { &quot;url&quot;: url, } var hrstart = process.hrtime() request.get(options, (err, res, body) =&gt; { if (err) return callback(err) var text='' //var xmlOptions = {object: true} logger.debug(`ISY: ${res.statusCode} - ${url}`) if (getText) { console.log() text = xmlparser.xml2json(body) } result = { isyresponse: text, statusCode: res.statusCode, seq: seq, elapsed: process.hrtime(hrstart)[1]/1000000 + 'ms', profileNum: profileNum } return callback(null, result) }).auth(process.env.ISY_USERNAME, process.env.ISY_PASSWORD) // Find a way to encrypt the password easily for users. //.auth(process.env.ISY_USERNAME, encrypt.decryptText(process.env.ISY_PASSWORD)) }, /** * Handles the Request from Polyglot calls TO the ISY and formats them appropriately based on type. * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} command - Command received to query to the ISY * @param {boolean} getText - Get full response text from ISY and package it in the response. True/False. Default is False * @param {function} callback - Simple (response) callback with the result success or fail. */ handleRequest(profileNum, data, command, gettext = false, callback){ var url = (this[command] || this['notfound']).call(this, profileNum, data, command) if (url){ this.getIsy(profileNum, url, data.seq ? data.seq : false, gettext, (err, result)=&gt; { if (err) logger.error(`ISY: ${err}`) if (callback) return callback(result) }) } else { logger.error(`ISY: handleRequest - ${command} did not return a valid URL.`) if (callback) { return callback() } } }, /** * Handles the status calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ status(profileNum, data, cmd) { var url=false if (data.address) { //var url = isy.makeApiUrl(this.profileNum, 'config', {'test': true}) var address = this.addNodePrefix(profileNum, data.address) var path = ['nodes', address, 'report', 'status', data.driver, data.value, data.uom] url = this.makeNodeUrl(profileNum, path) } else { logger.error(`ISY: address not found in ${cmd} call.`) } return url }, /** * Handles the command calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ command(profileNum, data, cmd){ var url=false if (data.address) { var address = this.addNodePrefix(profileNum, data.address) var path = ['nodes', address, 'report', 'cmd', data.command] var checks = [data.value, data.uom] for (var index in checks) { if (checks[index] !== null) { path.push(checks[index]) } } var url = this.makeNodeUrl(profileNum, path) } else { logger.error(`ISY: Error address not found in ${cmd} call.`) } return url }, /** * Handles the addnode calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ addnode(profileNum, data, cmd){ var url=false if (data.address &amp;&amp; data.primary &amp;&amp; data.name &amp;&amp; data.node_def_id) { var address = this.addNodePrefix(profileNum, data.address) var primary = this.addNodePrefix(profileNum, data.primary) var path = ['nodes', address, 'add', data.node_def_id] var queryargs = { 'primary': primary, 'name': data.name } var url = this.makeNodeUrl(profileNum, path, queryargs) } else { logger.error(`ISY: Error address, primary, node_def_id, or name not found in ${cmd} call.`) } return url }, /** * Handles the removenode calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ removenode(profileNum, data, cmd){ var url=false if (data.address) { var address = this.addNodePrefix(profileNum, data.address) var path = ['nodes', address, 'remove'] var url = this.makeNodeUrl(profileNum, path) } else { logger.error(`ISY: Error address not found in ${cmd} call.`) } return url }, /** * Handles the restcall calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ restcall(profileNum, data, cmd) { var url=false if (data.api) { url = this.makeApiUrl(data.api, data.args) } else { logger.error(`ISY: api not found in ${cmd} call.`) } return url }, /** * Handles the request calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ request(profileNum, data, cmd){ var url=false if (data.requestId) { var path = ['report', 'request', data.requestId, data.success ? 'success' : 'fail'] var url = this.makeNodeUrl(profileNum, path) } else { logger.error(`ISY: Error request_id or success not found in ${cmd} call.`) } return url }, /** * Handles the inital getVersion request to verify ISY connectivity * @method * @param {function} callback - Simple (err) callback if there is an error. Otherwise no parameters passed. We save the result in the config/config singleton. */ getVersion(callback) { var version = '' var data = {} data['api'] = 'config' var url = this.restcall(0, data, 'getVersion') this.getIsy(0, url, false, true, (err, result) =&gt; { try { config.isyVersion = result.isyresponse.configuration.app_version logger.info(`ISY: Got Version ${config.isyVersion}`) } catch (e) { logger.error(`ISY: Failed to get version. Error: ${e}`) if (callback) return callback(e) } if (callback) return callback() }) }, /** * Handles the incoming install command from ISY * Not Implemented from the ISY at the moment. (I can't get ISY to send me the command) * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restInstall(req, res) { logger.debug('Got REST Install ', req.params, req.query) }, /** * Handles the incoming status command from ISY and passes it along to the NodeServer * This handles the succesful response to ISY as well. * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restStatus(req, res) { let message = { address: req.params.nodeAddress === &quot;0&quot; ? 'all' : req.params.nodeAddress } mqtt.makeResponse(req.params.id, req.params.command, message) if (req.query.requestId) { let data = { requestId: req.query.requestId, success: true } this.handleRequest(req.params.id, data, 'request') } }, /** * Handles the addnodes command from ISY * Not implemented on the ISY side yet. * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restAddNodes(req, res) { console.log(req.params, req.query) }, /** * Handles the report command from ISY * Not implemented on the ISY side yet. * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restReport(req, res) { console.log(req.params, req.query) }, /** * Handles the 'command' command from ISY and passes it to the NodeServer to exectue a command. e.g. DON/DOF/etc. * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restCommand(req, res) { logger.debug(`Sending ${req.params.command} to ${req.params.nodeAddress}`) command = { address: req.params.nodeAddress.slice(5), cmd: req.params.command, value: req.params.value || undefined, uom: req.params.uom || undefined, query: req.query || undefined } mqtt.makeResponse(req.params.id, 'command', command) } } × Search results Close "},"modules_logger.js.html":{"id":"modules_logger.js.html","title":"Source: modules/logger.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/logger.js /* Instantiate the logger for all modules */ const os = require('os') /** * Logger Module * @module modules/logger * @version 2.0 */ /** * Default log level is INFO. If .env parameter of NODE_ENV is set to to 'development' then we up the level to DEBUG */ var logLevel = 'info' /** * Default log level is INFO. If .env parameter of NODE_ENV is set to to 'development' then we log to the console as well as the file. */ var transports = [] var winston = require('winston') var tsFormat = () =&gt; (new Date()).toLocaleString() if (process.env.NODE_ENV === 'development') { logLevel = 'debug' transports.push( new (winston.transports.Console)({ timestamp: tsFormat, level: logLevel, colorize: true, handleExceptions: true, humanReadableUnhandledException: true })) } transports.push( new (winston.transports.File)({ filename: os.homedir() + '/.polyglot/log/debug.log', timestamp: tsFormat, level: logLevel, maxsize: 1000*1024, maxFiles: 10, handleExceptions: true, humanReadableUnhandledException: true, exitOnError: true, json: false }) ) var winston = new (winston.Logger)({ transports: transports }) module.exports = winston × Search results Close "},"modules_mqtt.js.html":{"id":"modules_mqtt.js.html","title":"Source: modules/mqtt.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/mqtt.js const logger = require('./logger') const mqtt = require('mqtt') const config = require('../config/config') /** * MQTT Module * @module modules/mqtt * @version 2.0 */ module.exports = { /** MQTT Client var */ Client: null, /** MQTT clientId var */ clientId: null, /** * MQTT Start Service and Connect via .env MQTT_HOST and MQTT_PORT provided. * @method * @param {function} callback - Callback when connected or if already started. */ startService(callback) { if (this.Client) { if (callback) return callback() } this.clientId = 'polyglot' var options = { keepalive: 60, clean: true, clientId: this.clientId, reconnectPeriod: 5000, will: { retain: true } } if(!process.env.MQTT_HOST || !process.env.MQTT_PORT) { logger.error('MQTT Address or Port not set... Check your Settings.') return } options['will']['topic'] = 'udi/polyglot/connections/polyglot' options['will']['payload'] = new Buffer(JSON.stringify({node: this.clientId, 'connected': false})) this.Client = mqtt.connect('mqtt://'+ process.env.MQTT_HOST + ':' + process.env.MQTT_PORT, options) this.Client.on('connect', () =&gt; { this.addSubscriptions() }) this.Client.on('message', (topic, payload) =&gt; { try { payload = JSON.parse(payload.toString()) } catch (e) { logger.error('MQTT: Badly formatted JSON input received. ' + e) return } this.parse(topic, payload) }) this.Client.on('reconnect', () =&gt; { config.mqttConnected = false logger.info('MQTT attempting reconnection to broker...') }) this.Client.on('error', (err) =&gt; { logger.error('MQTT recieved error: ' + err.toString()) }) logger.info('MQTT Services Started.') if (callback) callback() }, /** * MQTT Addsubscriptions to Polyglot topics and existing NodeServer topics. * @method */ addSubscriptions() { this.Client.subscribe('udi/polyglot/connections/#', (err, granted) =&gt; { if (err) { logger.error('Error: ' + err.toString()) return } config.mqttConnected = true logger.info('MQTT: Subscribe Successful ' + granted[0]['topic'] + &quot; QoS: &quot; + granted[0]['qos']) this.publish('udi/polyglot/connections/polyglot', {node: this.clientId, 'connected': true}, { retain: true }) }) this.Client.subscribe('udi/polyglot/frontend/settings') this.Client.subscribe('udi/polyglot/frontend/nodeservers') config.nodeServers.forEach((nodeServer) =&gt; { this.Client.subscribe('udi/polyglot/ns/' + nodeServer.profileNum, (err, granted) =&gt; { if (err) { logger.error('Error: ' + err.toString()) return } logger.info('MQTT: Subscribe Successful ' + granted[0]['topic'] + &quot; QoS: &quot; + granted[0]['qos']) }) }) }, /** * MQTT Addsubscription to new NodeServer * @method * @param {number} profileNum - add new subscription to NodeServer with profileNum. */ addSubscription(profileNum) { this.Client.subscribe('udi/polyglot/ns/' + profileNum, (err, granted) =&gt; { if (err) { logger.error('Error: ' + err.toString()) return } logger.info('MQTT: Subscribe Successful ' + granted[0]['topic'] + &quot; QoS: &quot; + granted[0]['qos']) }) }, delSubscription(profileNum) { this.Client.unsubscribe('udi/polyglot/ns/' + profileNum, (err, granted) =&gt; { if (err) { logger.error('Error: ' + err.toString()) return } logger.info(`MQTT: Unsubscribed Successfully from NodeServer ${profileNum}`) }) }, /** * MQTT Stop Service * @method * @param {function} callback - Callback when service is and conneciton is clear. */ stopService(callback) { if(this.Client){ this.publish('udi/polyglot/connections/polyglot', {node: this.clientId, 'connected': false}, { retain: true }) logger.info('MQTT Services Stopping Gracefully.') this.Client.end(true, () =&gt; { this.Client = null if(callback) { callback() } }) } else { if(callback) { callback() } } }, /** * MQTT Make Response * @method * @param {string} topic - topic to publish to. Should be either 'connections' or the profileNum of the NodeServer * @param {string} command - Command to send, e.g 'status', etc. * @param {object} message - Dictionary object of message to send. JSON format. */ makeResponse(topic, command, message) { if (topic === 'connections' || topic === 'udi/polyglot/connections/polyglot') { topic = 'udi/polyglot/connections/polyglot' } else { topic = 'udi/polyglot/ns/' + topic } try { var response = {'node': 'polyglot'} response[command] = message } catch (e) { var response = { 'node': 'polyglot', 'data': { 'error': e } } } this.publish(topic, response) }, /** * MQTT Once MakeResponse is complete, publish the message to MQTT * @method * @param {string} topic - topic to publish to. Should be either 'connections' or the profileNum of the NodeServer * @param {object} message - Dictionary object of message to send. JSON format. * @param {object} options - Typically used for {retain: True/False} to retain the last message. [Optional] * @param {function} callback - Callback when publish is complete. [Optional] */ publish(topic, message, options, callback) { message = JSON.stringify(message) this.Client.publish(topic, message, options, callback) }, /** * MQTT Parse incoming message from MQTT * @method * @param {string} topic - topic received on. * @param {object} message - Dictionary object of message. JSON parsed into object. */ parse(topic, message) { var parse = false if (message.node === 'polyglot') { return } if (topic === 'udi/polyglot/frontend/settings') { require('../models/settings').updateSettings(message) return } if (topic === 'udi/polyglot/frontend/nodeservers') { require('../models/nodeserver').parseFrontend(message) return } logger.debug('MQTT Message: ' + topic + &quot;: &quot; + JSON.stringify(message)) try { if (topic.substring(0,25) === 'udi/polyglot/connections/') { if (message.node.toString().substring(0,18) === 'polyglot_frontend-') { logger.info('MQTT: Frontend Websockets interface ' + (message.connected ? ' Connected.' : ' Disconnected.')) } else if (message.node === config.nodeServers[message.node].profileNum) { try { config.nodeServers[message.node].checkCommand(message) } catch (e) { logger.error(`MQTT CheckCommand Error: ${e}`) } } } else if ((topic.substring(0,16) === 'udi/polyglot/ns/') &amp;&amp; (topic.slice(-1) === message.node)) { if (message.node === config.nodeServers[message.node].profileNum) { try { config.nodeServers[message.node].checkCommand(message) } catch (e) { logger.error(`MQTT CheckCommand Error: ${e}`) } } } else { logger.debug('MQTT: Did not match any parse filters. Ignoring. This usually means ' + 'the node value is incorrect. Make sure it matches an active NodeServer and you are publishing to the correct topic. ' + message) } } catch (err) { logger.error('MQTT Parse Error: ' + err) } } } × Search results Close "},"modules_web.js.html":{"id":"modules_web.js.html","title":"Source: modules/web.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/web.js const express = require('express') const path = require('path') const bodyParser = require('body-parser') const cors = require('cors') //const forceSSL = require('express-force-ssl') const fs = require('fs') const http = require('http') const https = require('https') const config = require('../config/config') const passport = require('passport') const compression = require('compression') const logger = require('./logger') const helpers = require('./helpers') /** * REST Web Interface Module * @module modules/web * @version 2.0 */ module.exports = { Server: null, /** * Express Start Web API Service and add routes. * @method */ startService() { if (!this.Server) { const app = express() const frontend = require('../routes/frontend') const rest = require('../routes/rest') // Port Number const port = process.env.HOST_PORT // Compression to gzip app.use(compression()) // CORS Middleware app.use(cors()) // Set Static Folder const staticFolder = path.join(__dirname, '../../public/') app.use(express.static(staticFolder)) // Body Parser Middleware app.use(bodyParser.json()) // Passport Middleware app.use(passport.initialize()) app.use(passport.session()) require('../config/passport')(passport) // /Users Routes app.use('/frontend/', frontend) app.use('/ns/', rest) // Error Handling app.use(function(err, req, res, next) { res.status(err.status || 500) res.json({'error': { message: err.message, error: err }}) }) // Index Route app.get('*', (req, res) =&gt; { res.sendFile(staticFolder + 'index.html') }) // Import SSL keys /* const ssl_options = { key: fs.readFileSync('./ssl/polyglot.key'), cert: fs.readFileSync('./ssl/polyglot.crt') } */ // ForceSSL on every page. // app.use(forceSSL) // Create Server Object //const secureServer = https.createServer(ssl_options, app) this.Server = http.createServer(app) //const io = socketio(this.Server, {namespace: 'frontend'}) //require('../sockets/frontend')(io) //require('../sockets/nodeserver').startService(io) // Start Server this.Server.listen(port, '0.0.0.0', () =&gt; { logger.info('Secure Server started on port ' + port) }) } }, /** * Express Stop Web API Service and add routes. This is run on shutdown. * @method * @param {function} callback - Callback when complete. */ stopService(callback) { logger.info('Stopping Web Service.') if (this.Server) { this.Server.close(() =&gt; { this.Server = null if(callback) { return callback() } }) } else { if(callback) { return callback() } } } } × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Modules Classes DriverSchema NodeSchema NodeServerModel UserModel × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Classes Classes DriverSchema NodeSchema NodeServerModel UserModel × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel polyglot-v2 2.0.4 UDI Polyglot v2Polyglot is a Middleware for the Universal Devices ISY product. × Search results Close "},"module-config_config.html":{"id":"module-config_config.html","title":"Module: config/config","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: config/config Config data pulled from the .env fileand some globally accessible internal variables Version: 2.0 Source: config/config.js, line 1 Members &lt;static&gt; dbConnected :boolean MongoDB is connected True/False Type: boolean Source: config/config.js, line 12 &lt;static&gt; isyVersion :string ISY Version returned from successful test of ISY credentials Type: string Source: config/config.js, line 22 &lt;static&gt; mqttConnected :boolean MQTT is connected True/False Type: boolean Source: config/config.js, line 17 &lt;static&gt; nodeServers :Array Array of NodeServerModel objects kept in resident memory as reflection of their database models.This allows for direct calling of NodeServerModel objects via nodeServers[profileNum]. The Array indexcorrelates to the NodeServer profileNum for ease of use. e.g. LiFX nodeserver with the profileNum of 8can be called via nodeServers[8].save() to save the NodeServer changes to the db for example. Type: Array Source: config/config.js, line 30 &lt;static&gt; settings :Object Settings Loaded from the ~/.polyglot/.env file using the dotenv NodeJS module. You SHOULD NEVER MODIFY THIS IN THE SOURCE. Just use the .env isyHost = '192.168.1.10' isyPort = '80' isyUsername = 'admin' isyPassword = 'password' isyHttps = true/false (This isn't tested yet) mqttHost = '192.168.1.12' (This CANNOT be 'localhost' or '127.0.0.1' as it is passed to the frontend for websocket connections. IT MUST BE THE HOST IP) mqttPort = '1883' (Default is 1883) mqttWSPort = '8083' (Default is 8083) Type: Object Source: config/config.js, line 43 × Search results Close "},"module-config_passport.html":{"id":"module-config_passport.html","title":"Module: config/passport","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: config/passport The passport module to wrap all authenticated functionsthat require the token to be accessed. (require(&quot;config/passport&quot;))(passport) Function to create the JWT Strategy for Passport. Parameters: Name Type Description passport module The Passport module is passed in to create a new JwtToken Strategy for authentication via header tokens. Source: config/passport.js, line 18 × Search results Close "},"module-models_nodeserver.html":{"id":"module-models_nodeserver.html","title":"Module: models/nodeserver","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: models/nodeserver NodeServer Model and Parent Class. AddNS uses 'new NodeServerModel' to reference the NodeServerSchema parent class to create a new MongoDB document via Mongoose Version: 2.0 Source: models/nodeserver.js, line 8 Classes DriverSchema NodeSchema NodeServerModel Methods &lt;static&gt; NodeServerModel.addns(name, profileNum, callback) Frontend called method to add a new NodeServer Parameters: Name Type Description name string Name of NodeServer being added profileNum number Profile Number of NodeServer being added callback addnsCallback Callback with response JSON Source: models/nodeserver.js, line 165 Returns: response - AddNS: {&quot;addns&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;},&quot;seq&quot;:53407} Success: {&quot;seq&quot;:53407,&quot;response&quot;:{&quot;success&quot;:true,&quot;msg&quot;:&quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;,&quot;nodeserver&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;}}} Fail: {&quot;seq&quot;:53408,&quot;response&quot;:{&quot;success&quot;:false,&quot;msg&quot;:&quot;NodeServer with that Profile Number already exists.&quot;}} Type object &lt;static&gt; NodeServerModel.getAllNodeServers(callback) Get all NodeServers from MongoDB Parameters: Name Type Description callback findArrayCallback Callback Passed into the Mongoose find method. Source: models/nodeserver.js, line 276 Returns: Type findArrayCallback &lt;static&gt; NodeServerModel.getNodeByName(name, callback) Get NodeServer from MongoDB by Name Parameters: Name Type Description name string Name of Node requested from MongoDB callback findCallback Callback Passed into the Mongoose find method. Source: models/nodeserver.js, line 289 Returns: Type findCallback &lt;static&gt; NodeServerModel.getNodeByProfileNum(number, callback) Get NodeServer from MongoDB by profileNum Parameters: Name Type Description number number profileNum of Node requested from MongoDB callback findCallback Callback Passed into the Mongoose find method. Source: models/nodeserver.js, line 303 Returns: Type findCallback &lt;static&gt; NodeServerModel.loadNodeServers(callback) Load all NodeServers from MongoDB on Polyglot Start-up Parameters: Name Type Description callback errOnlyCallback Callback returned when complete Source: models/nodeserver.js, line 315 &lt;static&gt; NodeServerModel.parseFrontend(message) Parse incoming Frontend messages Parameters: Name Type Description message Object Incoming JSON parsed object from the frontend. Only commands accepted are 'addns' and 'delns' currently Source: models/nodeserver.js, line 216 &lt;static&gt; NodeServerModel.sendUpdate() Sends an update to the frontend topic on detection of a change in NodeServer properties or sub properties like driver updates or state changes. Source: models/nodeserver.js, line 144 Returns: response - MQTT Message sent to the frontends. e.g.: {&quot;nodeservers&quot;:[{&quot;name&quot;:&quot;LiFX&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;nodes&quot;:[{&quot;address&quot;:&quot;lifx_1234&quot;,&quot;name&quot;:&quot;LIFX_Lamp&quot;,&quot;_id&quot;:&quot;59338d1c2930bf7cc92842d1&quot;,&quot;drivers&quot;: [{&quot;driver&quot;:&quot;ST&quot;,&quot;_id&quot;:&quot;59338624cd92117adb9349ca&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;123.3&quot;},{&quot;driver&quot;:&quot;GV5&quot;,&quot;_id&quot;:&quot;59338624cd92117adb9349c9&quot;,&quot;uom&quot;:23,&quot;value&quot;:&quot;10&quot;}], &quot;isprimary&quot;:true,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496550684087&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true},{&quot;address&quot;:&quot;lifx_1235&quot;, &quot;name&quot;:&quot;Z_Strip&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d941&quot;,&quot;drivers&quot;: [{&quot;driver&quot;:&quot;ST&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d943&quot;,&quot;uom&quot;:56,&quot;value&quot;:&quot;593.3&quot;}, {&quot;driver&quot;:&quot;GV1&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d942&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:false,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496552508813&quot;, &quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true}],&quot;token&quot;:null,&quot;encryptPayload&quot;:false,&quot;time_added&quot;:&quot;1496545371618&quot;,&quot;isConnected&quot;:true}]} Type object Type Definitions addnsCallback(error, response) Parameters: Name Type Description error string An Error if returned response Object {&quot;seq&quot;:53407,&quot;response&quot;:{&quot;success&quot;:true,&quot;msg&quot;:&quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;,&quot;nodeserver&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;}}} Source: models/nodeserver.js, line 980 errOnlyCallback(error) Parameters: Name Type Description error string An Error if encountered Source: models/nodeserver.js, line 998 findArrayCallback(error, documents) Parameters: Name Type Description error string An Error if encountered documents Object Array of documents returned by Mongoose Find Source: models/nodeserver.js, line 986 findCallback(error, document) Parameters: Name Type Description error string An Error if encountered document Object Document returned by Mongoose FindOne Source: models/nodeserver.js, line 992 responseCallback(error, response) Parameters: Name Type Description error string An Error if encountered response Object Object response returned to callback if no error occurred. Source: models/nodeserver.js, line 1003 × Search results Close "},"module-models_nodeserver-DriverSchema.html":{"id":"module-models_nodeserver-DriverSchema.html","title":"Class: DriverSchema","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Class: DriverSchema models/nodeserver~ DriverSchema new DriverSchema(driver, value, uom) MongoDB - Driver Child Schema Parameters: Name Type Description driver string Driver Name e.g. 'ST', 'RR', 'GV1', etc value string String representation of the value of the driver. uom number Integer of the UOM representing the value of the driver. Source: models/nodeserver.js, line 14 Extends NodeSchema × Search results Close "},"module-models_nodeserver-NodeSchema.html":{"id":"module-models_nodeserver-NodeSchema.html","title":"Class: NodeSchema","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Class: NodeSchema models/nodeserver~ NodeSchema new NodeSchema(address, added, enabled, name, node_def_id, time_added, primary, isprimary, drivers) MongoDB - Nodes Child Schema Parameters: Name Type Description address string Node address value e.g. 'lifxcontrol' added boolean Represents if the node is added and present in the ISY. enabled boolean Represents the enabled state of the node. name string Descriptive name of the node. node_def_id string Node Definition ID represented in the profile.zip for this node type. time_added string DateString in epoch of when the node was added to Polyglot primary string The node address of the nodes primary parent node. This could be itself in some cases. isprimary boolean Is this node a primary for other nodes. drivers Object Array of DriverSchema Objects Source: models/nodeserver.js, line 37 Extends NodeServerModel × Search results Close "},"module-models_nodeserver-NodeServerModel.html":{"id":"module-models_nodeserver-NodeServerModel.html","title":"Class: NodeServerModel","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Class: NodeServerModel models/nodeserver~ NodeServerModel new NodeServerModel(name, profileNum, encryptPayload, token, time_added, isConnected, logPrefix, nodes) MongoDB - NodeServer Parent Schema for creating a new NodeServer Database Object Parameters: Name Type Description name string NodeServer name that is displayed in Polyglot. e.g. 'LiFX' or 'Nest' profileNum string ProfileNumber of the NodeServer. This must be a unique number between 1 - 10 that is not already defined in ISY. encryptPayload boolean Should we encrypt the payload using our .env secret? [NOT IMPLEMENTED YET] token string Encryption token taken from the .env file and saved to the DB [NOT IMPLEMENTED YET] time_added string DateString in epoch of when the NodeServer was added to Polyglot isConnected boolean Is Polyglot Connected to MQTT? logPrefix string Allows for custom logPrefixes to be defined per NodeServer if needed. nodes Object Array of NodeSchema Objects Source: models/nodeserver.js, line 87 Methods addnode(data, command) Instance Method for NodeServer to handle 'addnode' Parameters: Name Type Description data object JSON parsed from incoming message e.g. {&quot;nodes&quot;: [{&quot;address&quot;: &quot;lifx_1236&quot;,&quot;name&quot;: &quot;LIFX_Lamp2&quot;,&quot;node_def_id&quot;: &quot;lifxcolor&quot;,&quot;primary&quot;: &quot;lifx_1234&quot;,&quot;drivers&quot;: [{&quot;driver&quot;: &quot;ST&quot;,&quot;value&quot;: &quot;123.3&quot;,&quot;uom&quot;: 20},{&quot;driver&quot;: &quot;GV5&quot;,&quot;value&quot;: &quot;10&quot;,&quot;uom&quot;: 23}]}], &quot;seq&quot;: 1000} command string The command received: 'addnode' Source: models/nodeserver.js, line 485 Returns: response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:1000,&quot;elapsed&quot;:&quot;100.425214ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;node lifx_1236 added successfully.&quot;,&quot;address&quot;:&quot;lifx_1236&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;25.251796ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1235 already exists on ISY&quot;,&quot;address&quot;:&quot;lifx_1235&quot;}}} Type object checkCommand() Instance Method for NodeServer to check input from MQTT and execute function if successful.Valid Commands: ['status', 'addnode','removenode', 'restcall', 'request', 'config', 'connected', 'command'] Source: models/nodeserver.js, line 352 command(data, command) Instance Method for NodeServer to handle 'command' Parameters: Name Type Description data object JSON parsed from incoming message e.g. {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;command&quot;: &quot;DON&quot;, &quot;value&quot;: 50.2, &quot;uom&quot;: 20} command string The command received: 'command' Source: models/nodeserver.js, line 430 Returns: response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;true&quot;,&quot;status&quot;:&quot;200&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;0&quot;}}},&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;19.073624ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;command&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;lifx_1234 DON sent sucessfully with 50.2&quot;,&quot;address&quot;:&quot;lifx_1234&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;400&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;2101&quot;}}},&quot;statusCode&quot;:400,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;10.852264ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;command&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_123 or asdf does not exist or is incorrect&quot;,&quot;address&quot;:&quot;lifx_123&quot;}}} Type object config(data, command) Instance Method to handle 'config' from NodeServer Parameters: Name Type Description data Object {&quot;node&quot;: &quot;1&quot;, &quot;config&quot;: null, &quot;seq&quot;: 1000} command string This command 'config'. Source: models/nodeserver.js, line 925 Returns: response - Returns existing NodeServer configuration: {&quot;config&quot;:{&quot;name&quot;:&quot;LiFX&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;nodes&quot;:[{&quot;address&quot;:&quot;lifx_1234&quot;,&quot;name&quot;:&quot;LIFX_Lamp2&quot;,&quot;drivers&quot;:[{&quot;driver&quot;:&quot;ST&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;123.3&quot;},{&quot;driver&quot;:&quot;GV5&quot;,&quot;uom&quot;:23,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:true,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496550684087&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true},{&quot;address&quot;:&quot;lifx_1235&quot;,&quot;name&quot;:&quot;TouchMe&quot;,&quot;drivers&quot;:[{&quot;driver&quot;:&quot;ST&quot;,&quot;uom&quot;:56,&quot;value&quot;:&quot;593.3&quot;},{&quot;driver&quot;:&quot;GV1&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:false,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496552508813&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true}],&quot;token&quot;:null,&quot;encryptPayload&quot;:false,&quot;time_added&quot;:&quot;1496545371618&quot;,&quot;isConnected&quot;:false}} Type Object connected(data, command) Instance Method to handle 'connected' from NodeServer Parameters: Name Type Description data Object {&quot;node&quot;: &quot;1&quot;, &quot;connected&quot;: true} or {&quot;node&quot;: &quot;1&quot;, &quot;connected&quot;: false} command string This command 'connected'. Source: models/nodeserver.js, line 951 deleteNodeServer(callback) Instance Method to delete this NodeServer from ISY automatically. This kicks off immediately after NodeServer is deleted via the frontend. Parameters: Name Type Description callback responseCallback (err, response) Callback when complete with error if present, or response if no error. Source: models/nodeserver.js, line 811 getNodesFromISY(callback) Instance Method to Query for Nodes for this NodeServer from ISYThis happens at Polyglot Startup to Sync the ISY and Polyglot Database Parameters: Name Type Description callback errOnlyCallback Callback when complete with only parameter being an error if there was one. Source: models/nodeserver.js, line 695 installNodeServer(callback) Instance Method to install this NodeServer to ISY automatically. This kicks off immediately after NodeServer is added to Polyglot via the frontend. Parameters: Name Type Description callback responseCallback (err, response) Callback when complete with error if present, or response if no error. Source: models/nodeserver.js, line 764 removenode(data, command) Instance Method for NodeServer to handle 'removenode' Parameters: Name Type Description data object JSON parsed from incoming message e.g. {&quot;node&quot;: &quot;1&quot;, &quot;removenode&quot;: {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;seq&quot;: 1004}} command string The command received: 'removenode' Source: models/nodeserver.js, line 622 Returns: response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;true&quot;,&quot;status&quot;:&quot;200&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;0&quot;}}},&quot;statusCode&quot;:200,&quot;seq&quot;:1004,&quot;elapsed&quot;:&quot;99.309321ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;removenode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;lifx_1235 removed successfully&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;403&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;5106&quot;}}},&quot;statusCode&quot;:403,&quot;seq&quot;:1004,&quot;elapsed&quot;:&quot;17.747168ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;removenode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;Could not remove lifx_1234. It is the primary for another node.&quot;}}} Type object request(data, command) Instance Method to handle 'request' from NodeServer Parameters: Name Type Description data Object {&quot;node&quot;: &quot;8&quot;, &quot;request&quot;: {&quot;requestId&quot;: &quot;3949&quot;, &quot;success&quot;: true}} command string This command 'request'. Source: models/nodeserver.js, line 897 Returns: result - Responds only on failure. Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:404,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;8.202375ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;request&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;ISY Returned 404 for request ID: 22&quot;,&quot;id&quot;:&quot;22&quot;}}} Type Object restcall(data, command) Instance Method for NodeServer to handle 'restcall' Parameters: Name Type Description data object JSON parsed from incoming message e.g. {&quot;api&quot;:&quot;nodes/n001_d073d51327cc&quot;,&quot;seq&quot;:10068,&quot;timeout&quot;:null} command string The command received: 'restcall' Source: models/nodeserver.js, line 458 Returns: response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;nodeInfo&quot;:{&quot;node&quot;:{&quot;flag&quot;:&quot;0&quot;,&quot;nodeDefId&quot;:&quot;lifxcolor&quot;,&quot;address&quot;:&quot;n001_d073d51327cc&quot;,&quot;name&quot;:&quot;LIFX Lamp&quot;,&quot;family&quot;:{&quot;instance&quot;:&quot;1&quot;,&quot;$t&quot;:&quot;10&quot;},&quot;parent&quot;:{&quot;type&quot;:&quot;1&quot;,&quot;$t&quot;:&quot;n001_lifxcontrol&quot;},&quot;type&quot;:&quot;1.1.0.0&quot;,&quot;enabled&quot;:&quot;true&quot;,&quot;deviceClass&quot;:&quot;0&quot;,&quot;wattage&quot;:&quot;0&quot;,&quot;dcPeriod&quot;:&quot;0&quot;,&quot;startDelay&quot;:&quot;0&quot;,&quot;endDelay&quot;:&quot;0&quot;,&quot;pnode&quot;:&quot;n001_lifxcontrol&quot;,&quot;ELK_ID&quot;:&quot;A07&quot;},&quot;properties&quot;:{}}},&quot;statusCode&quot;:200,&quot;seq&quot;:10068,&quot;elapsed&quot;:&quot;29.861932ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;restcall&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;nodes/n001_d073d51327cc executed sucessfully&quot;,&quot;api&quot;:&quot;nodes/n001_d073d51327cc&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;404&quot;}},&quot;statusCode&quot;:404,&quot;seq&quot;:10068,&quot;elapsed&quot;:&quot;15.433125ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;restcall&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;ISY Returned 404 for nodes/n001_d073d51327c&quot;,&quot;api&quot;:&quot;nodes/n001_d073d51327c&quot;}}} Type object sendResult(command, result, success, reason, extra) Instance Method to Send a result message to the NodeServer via MQTT Parameters: Name Type Description command string Command NodeServer is sending a result for. result Object The result object data. success boolean True/false reason string Sucess reason extra Object Extra Parameters to send to the NodeServer if needed. Source: models/nodeserver.js, line 876 status(data, command) Instance Method for NodeServer to handle 'status' Parameters: Name Type Description data object JSON parsed from incoming command message e.g. {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;driver&quot;: &quot;GV6&quot;, &quot;value&quot;: 50.2, &quot;uom&quot;: 20} command string The command received: 'status' Source: models/nodeserver.js, line 382 Returns: response - ONLY if an error occurs will a MQTT response message will be sent back to the NodeServer: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:404,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;9.735427ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;status&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1234 or GV18 does not exist&quot;,&quot;address&quot;:&quot;lifx_1234&quot;}}} Type object toJSON() Instance Method for NodeServer to return a JSON object of itself. Source: models/nodeserver.js, line 339 Returns: nodeserver - Returns JSON parsed Object representation of the NodeServer Type Object × Search results Close "},"module-models_user.html":{"id":"module-models_user.html","title":"Module: models/user","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: models/user User Model and Class. Version: 2.0 Source: models/user.js, line 6 Classes UserModel Methods &lt;static&gt; UserModel.addUser(password, callback) Compare salts and hashes with the password using bcrypt. This has become problematic on older machines such as the Raspberry Pi 1.It is extremely slow to do the comparison. Gotta find a better way. Maybe less salts. Parameters: Name Type Description password string Password attempting to authenticate with. callback compareCallback Callback Passed into the Mongoose find method. Source: models/user.js, line 86 &lt;static&gt; UserModel.addUser(newUser, callback) Adduser salts and hashes the password using bcrypt before saving it to the database. This has become problematic on older machines such as the Raspberry Pi 1.It is extremely slow to do the comparison. Gotta find a better way. Maybe less salts. Parameters: Name Type Description newUser Object new instance of UserModel callback saveCallback Callback Passed into the Mongoose find method. Source: models/user.js, line 65 &lt;static&gt; UserModel.getUserByUsername(username, callback) MongoDB gets user from database by Username. Parameters: Name Type Description username string Username to search for. callback findCallback Callback Passed into the Mongoose find method. Source: models/user.js, line 50 &lt;static&gt; UserModel.sendUpdate(id, callback) MongoDB gets user from database by ID. Parameters: Name Type Description id string ID to search for. callback findCallback Callback Passed into the Mongoose find method. Source: models/user.js, line 38 Type Definitions compareCallback(error, isMatch) Parameters: Name Type Description error string An Error if encountered isMatch boolean True/False is password hashed successfully with bcrypt. Source: models/user.js, line 111 findCallback(error, document) Parameters: Name Type Description error string An Error if encountered document Object Document returned by Mongoose FindOne Source: models/user.js, line 99 saveCallback(error, document) Parameters: Name Type Description error string An Error if encountered document Object Document returned if sucessfully saved by Mongoose save method Source: models/user.js, line 105 × Search results Close "},"module-models_user-UserModel.html":{"id":"module-models_user-UserModel.html","title":"Class: UserModel","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Class: UserModel models/user~ UserModel new UserModel(username, password) MongoDB - UserSchema for creating a new User Database Object Parameters: Name Type Description username string Username of new User password string Password of new User Source: models/user.js, line 12 × Search results Close "},"module-modules_db.html":{"id":"module-modules_db.html","title":"Module: modules/db","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/db Database Module Version: 2.0 Source: modules/db.js, line 12 Members &lt;static&gt; Server MongoDB Connection var Source: modules/db.js, line 19 Methods &lt;static&gt; startService(callback) MongoDB Start Service and Connect via .env MONGO_URI provided. Parameters: Name Type Description callback startCallback Callback when connected and all NodeServers were retrieved. Source: modules/db.js, line 26 &lt;static&gt; stopService(callback) MongoDB Stop Service run on program shutdown. Parameters: Name Type Description callback stopCallback Callback when shutdown or error. Source: modules/db.js, line 76 Type Definitions startCallback(error, documents) Parameters: Name Type Description error string An Error if encountered documents Object Documents returned if sucessfully connected and retrieved existing NodeServer documents. Source: modules/db.js, line 89 stopCallback(error) Parameters: Name Type Description error string An Error if encountered Source: modules/db.js, line 95 × Search results Close "},"module-modules_encryption.html":{"id":"module-modules_encryption.html","title":"Module: modules/encryption","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/encryption The encryption module to encrypt communications between NodeServers and Polyglotthis is tested, however it is not enabled as of release 2.0 Version: 2.0 Source: modules/encryption.js, line 6 Methods &lt;static&gt; decryptText(text) decryptText Parameters: Name Type Description text string Text to decrypt Source: modules/encryption.js, line 31 Returns: Decrypted Text Type string &lt;static&gt; encryptText(text) encryptText Parameters: Name Type Description text string Text to encrypt Source: modules/encryption.js, line 18 Returns: Encrypted Text Type string × Search results Close "},"module-modules_helpers.html":{"id":"module-modules_helpers.html","title":"Module: modules/helpers","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/helpers Generic Helpers Module that has a couple of various methods that didn't fit elsewhere. Version: 2.0 Source: modules/helpers.js, line 10 Methods &lt;static&gt; restartServices() restartServices is an external function to stop then restart the MQTT service and re-initiate a NodeServer Resync Source: modules/helpers.js, line 54 &lt;static&gt; resyncNodesToISY(callback) resyncNodesToISY wraps a couple of database/ISY checks to make sure the ISY and Local MongoDB are in sync. Parameters: Name Type Description callback function Simple callback function that returns on error or when function is complete. Source: modules/helpers.js, line 32 &lt;static&gt; saveNodeServers() saveNodeServers will cycle through all the NodeServers and save the current state to MongoDB. This occurrs automatically before shutdown. Source: modules/helpers.js, line 80 &lt;static&gt; shutdown() shutdown is the program stop function to terminate the application gracefully. Source: modules/helpers.js, line 67 × Search results Close "},"module-modules_isy.html":{"id":"module-modules_isy.html","title":"Module: modules/isy","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/isy ISY API Module for REST calls to the ISY Interfaces Version: 2.0 Source: modules/isy.js, line 10 Methods &lt;static&gt; addnode(profileNum, data, cmd) Handles the addnode calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 166 &lt;static&gt; addNodePrefix(profileNum, nod) Automactially adds the ISY Node Prefix onto the address before querying the API. Parameters: Name Type Description profileNum number The NodeServer profileNum. nod string The NodeServer address id Source: modules/isy.js, line 23 &lt;static&gt; command(profileNum, data, cmd) Handles the command calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 143 &lt;static&gt; getIsy(profileNum, url, seq, getText, callback) Performs the actual query to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum url string The URL created by makeNodeUrl or makeApiUrl seq number Sequence number to verify response on specific call getText boolean Get full response text from ISY and package it in the response. True/False callback function Simple (err, response) callback with the result success or fail. Source: modules/isy.js, line 69 &lt;static&gt; getVersion(callback) Handles the inital getVersion request to verify ISY connectivity Parameters: Name Type Description callback function Simple (err) callback if there is an error. Otherwise no parameters passed. We save the result in the config/config singleton. Source: modules/isy.js, line 234 &lt;static&gt; handleRequest(profileNum, data, command, getText, callback) Handles the Request from Polyglot calls TO the ISY and formats them appropriately based on type. Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. command string Command received to query to the ISY getText boolean Get full response text from ISY and package it in the response. True/False. Default is False callback function Simple (response) callback with the result success or fail. Source: modules/isy.js, line 105 &lt;static&gt; makeApiUrl(api, path_args) Creates the API URL to query ISY/rest/{api}/?{path_args} Parameters: Name Type Description api string The ISY API path to query path_args object Dictionary of path arguments appended to the URL. Source: modules/isy.js, line 34 &lt;static&gt; makeNodeUrl(profileNum, path, path_args) Creates the Node URL to query ISY/rest/ns/{profileNum}/{path}/?{path_args} Parameters: Name Type Description profileNum number The NodeServer profileNum path string The ISY path to query path_args object Dictionary of path arguments appended to the URL. Source: modules/isy.js, line 51 &lt;static&gt; removenode(profileNum, data, cmd) Handles the removenode calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 188 &lt;static&gt; request(profileNum, data, cmd) Handles the request calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 220 &lt;static&gt; restAddNodes(req, res) Handles the addnodes command from ISYNot implemented on the ISY side yet. Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 296 &lt;static&gt; restcall(profileNum, data, cmd) Handles the restcall calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 205 &lt;static&gt; restCommand(req, res) Handles the 'command' command from ISY and passes it to the NodeServer to exectue a command. e.g. DON/DOF/etc. Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 321 &lt;static&gt; restInstall(req, res) Handles the incoming install command from ISYNot Implemented from the ISY at the moment. (I can't get ISY to send me the command) Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 260 &lt;static&gt; restReport(req, res) Handles the report command from ISYNot implemented on the ISY side yet. Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 309 &lt;static&gt; restStatus(req, res) Handles the incoming status command from ISY and passes it along to the NodeServerThis handles the succesful response to ISY as well. Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 273 &lt;static&gt; status(profileNum, data, cmd) Handles the status calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 125 × Search results Close "},"module-modules_logger.html":{"id":"module-modules_logger.html","title":"Module: modules/logger","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/logger Logger Module Version: 2.0 Source: modules/logger.js, line 6 Members &lt;inner&gt; logLevel Default log level is INFO. If .env parameter of NODE_ENV is set to to 'development' then we up the level to DEBUG Source: modules/logger.js, line 15 &lt;inner&gt; transports Default log level is INFO. If .env parameter of NODE_ENV is set to to 'development' then we log to the console as well as the file. Source: modules/logger.js, line 19 × Search results Close "},"module-modules_mqtt.html":{"id":"module-modules_mqtt.html","title":"Module: modules/mqtt","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/mqtt MQTT Module Version: 2.0 Source: modules/mqtt.js, line 5 Members &lt;static&gt; Client MQTT Client var Source: modules/mqtt.js, line 13 &lt;static&gt; clientId MQTT clientId var Source: modules/mqtt.js, line 15 Methods &lt;static&gt; addSubscription(profileNum) MQTT Addsubscription to new NodeServer Parameters: Name Type Description profileNum number add new subscription to NodeServer with profileNum. Source: modules/mqtt.js, line 100 &lt;static&gt; addSubscriptions() MQTT Addsubscriptions to Polyglot topics and existing NodeServer topics. Source: modules/mqtt.js, line 72 &lt;static&gt; makeResponse(topic, command, message) MQTT Make Response Parameters: Name Type Description topic string topic to publish to. Should be either 'connections' or the profileNum of the NodeServer command string Command to send, e.g 'status', etc. message object Dictionary object of message to send. JSON format. Source: modules/mqtt.js, line 145 &lt;static&gt; parse(topic, message) MQTT Parse incoming message from MQTT Parameters: Name Type Description topic string topic received on. message object Dictionary object of message. JSON parsed into object. Source: modules/mqtt.js, line 184 &lt;static&gt; publish(topic, message, options, callback) MQTT Once MakeResponse is complete, publish the message to MQTT Parameters: Name Type Description topic string topic to publish to. Should be either 'connections' or the profileNum of the NodeServer message object Dictionary object of message to send. JSON format. options object Typically used for {retain: True/False} to retain the last message. [Optional] callback function Callback when publish is complete. [Optional] Source: modules/mqtt.js, line 173 &lt;static&gt; startService(callback) MQTT Start Service and Connect via .env MQTT_HOST and MQTT_PORT provided. Parameters: Name Type Description callback function Callback when connected or if already started. Source: modules/mqtt.js, line 22 &lt;static&gt; stopService(callback) MQTT Stop Service Parameters: Name Type Description callback function Callback when service is and conneciton is clear. Source: modules/mqtt.js, line 125 × Search results Close "},"module-modules_web.html":{"id":"module-modules_web.html","title":"Module: modules/web","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttmodules/web Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/web REST Web Interface Module Version: 2.0 Source: modules/web.js, line 16 Methods &lt;static&gt; startService() Express Start Web API Service and add routes. Source: modules/web.js, line 29 &lt;static&gt; stopService(callback) Express Stop Web API Service and add routes. This is run on shutdown. Parameters: Name Type Description callback function Callback when complete. Source: modules/web.js, line 96 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
